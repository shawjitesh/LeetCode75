# 🚀 LeetCode 75 Solutions

<div align="center">

![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)
![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)
![GitHub](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white)

## A comprehensive collection of solutions to the popular LeetCode 75 coding problems study plan

[![GitHub stars](https://img.shields.io/github/stars/shawjitesh/LeetCode75?style=social)](https://github.com/shawjitesh/LeetCode75)
[![GitHub forks](https://img.shields.io/github/forks/shawjitesh/LeetCode75?style=social)](https://github.com/shawjitesh/LeetCode75)

</div>

---

## 📖 About This Repository

This repository contains my solutions to the **LeetCode 75** study plan, a curated collection of essential coding problems designed to help developers master fundamental algorithms and data structures. The LeetCode 75 study plan is widely recognized as one of the most effective ways to prepare for technical interviews and strengthen coding skills.

### 🎯 What is LeetCode 75?

The LeetCode 75 study plan is a carefully selected set of 75 coding problems that cover:

- **Array & String** manipulation
- **Two Pointers** technique
- **Sliding Window** problems
- **Prefix Sum** techniques
- **HashMap/Set** data structures
- **Stack** and **Queue** operations
- **Linked List** algorithms
- **Tree** traversals and manipulations
- **Graph** algorithms
- **Dynamic Programming** concepts
- **Binary Search** techniques
- **Backtracking** algorithms

## 🗂️ Repository Structure

```text
LeetCode75/
├── pom.xml                          # Maven project configuration
├── src/
│   └── main/
│       └── java/
│           ├── Array/
│           │   └── String/
│           │       ├── MergeStringsAlternately.java
│           │       ├── GreatestCommonDivisorOfStrings.java
│           │       ├── KidsWithTheGreatestNumberOfCandies.java
│           │       ├── CanPlaceFlowers.java
│           │       ├── ReverseVowelsOfAString.java
│           │       ├── ReverseWordsInAString.java
│           │       ├── ProductOfArrayExceptSelf.java
│           │       ├── IncreasingTripletSubsequence.java
│           │       └── StringCompression.java
│           ├── TwoPointers/
│           │   ├── MoveZeroes.java
│           │   ├── IsSubsequence.java
│           │   ├── ContainerWithMostWater.java
│           │   └── MaxNumberOfKSumPairs.java
│           ├── SlidingWindow/
│           │   ├── MaximumAverageSubarrayI.java
│           │   ├── MaximumNumberOfVowelsInASubstringOfGivenLength.java
│           │   ├── MaxConsecutiveOnesIII.java
│           │   └── LongestSubarrayOf1sAfterDeletingOneElement.java
│           ├── PrefixSum/
│           │   ├── FindTheHighestAltitude.java
│           │   └── FindPivotIndex.java
│           ├── HashMap/
│           │   └── Set/
│           │       ├── FindTheDifferenceOfTwoArrays.java
│           │       ├── UniqueNumberOfOccurrences.java
│           │       ├── DetermineIfTwoStringsAreClose.java
│           │       └── EqualRowAndColumnPairs.java
│           ├── Stack/
│           │   ├── RemovingStarsFromAString.java
│           │   ├── AsteroidCollision.java
│           │   └── DecodeString.java
│           ├── Queue/
│           │   ├── NumberOfRecentCalls.java
│           │   └── Dota2Senate.java
│           ├── LinkedList/
│           │   ├── ListNode.java
│           │   ├── DeleteTheMiddleNodeOfALinkedList.java
│           │   ├── MaximumTwinSumOfALinkedList.java
│           │   ├── OddEvenLinkedList.java
│           │   └── ReverseLinkedList.java
│           ├── BinarySearchTree/
│           │   ├── TreeNode.java
│           │   ├── SearchInABinarySearchTree.java
│           │   └── DeleteNodeInABST.java
│           ├── BinaryTree/
│           │   ├── TreeNode.java
│           │   ├── DFS/
│           │   │   ├── MaximumDepthOfBinaryTree.java
│           │   │   ├── LeafSimilarTrees.java
│           │   │   ├── CountGoodNodesInBinaryTree.java
│           │   │   ├── PathSumIII.java
│           │   │   ├── LongestZigZagPathInABinaryTree.java
│           │   │   └── LowestCommonAncestorOfABinaryTree.java
│           │   └── BFS/
│           │       ├── BinaryTreeRightSideView.java
│           │       └── MaximumLevelSumOfABinaryTree.java
│           ├── Graphs/
│           │   ├── DFS/
│           │   │   ├── KeysAndRooms.java
│           │   │   ├── NumberOfProvinces.java
│           │   │   ├── ReorderRoutesToMakeAllPathsLeadToTheCityZero.java
│           │   │   └── EvaluateDivision.java
│           │   └── BFS/
│           │       ├── NearestExitFromEntranceInMaze.java
│           │       └── RottingOranges.java
│           ├── BinarySearch/
│           │   └── GuessNumberHigherOrLower.java
│           └── Backtracking/
│               ├── CombinationSumIII.java
│               └── LetterCombinationsOfAPhoneNumber.java
├── target/                          # Maven build output directory
├── .github/                         # GitHub workflows and templates
│   ├── workflows/
│   │   ├── ci.yml                   # Continuous Integration
│   │   └── monitoring.yml           # Repository monitoring
│   └── ISSUE_TEMPLATE/
│       ├── bug_report.md
│       ├── feature_request.md
│       └── solution_request.md
├── README.md
├── WARP.md
├── WIKI.md
├── CONTRIBUTING.md
├── CODE_OF_CONDUCT.md
├── LICENSE
└── SECURITY.md
```

## 🚀 Quick Start

### Prerequisites

- **Java 21 or higher** installed on your system
- **Maven 3.6 or higher** for building and managing dependencies
- **Git** for cloning the repository
- **IDE** of your choice (IntelliJ IDEA, Eclipse, VS Code, etc.)

### 📋 Setup Instructions

#### 1. Clone the Repository

```bash
git clone https://github.com/shawjitesh/LeetCode75.git
cd LeetCode75
```

#### 2. Verify Java and Maven Installation

```bash
# Check Java version (should be 21 or higher)
java -version
javac -version

# Check Maven version (should be 3.6 or higher)
mvn -version
```

### 🛠️ IDE Setup

#### IntelliJ IDEA

1. Open IntelliJ IDEA
2. Select "Open" and navigate to the cloned repository
3. IntelliJ will automatically detect the Maven project structure
4. Configure JDK 21 if prompted
5. Wait for Maven to download dependencies and index the project
6. Use the Maven tool window to build and run the project

#### VS Code

1. Install the "Extension Pack for Java" by Microsoft
2. Install the "Maven for Java" extension for better Maven support
3. Open the repository folder in VS Code
4. VS Code will automatically configure the Java environment and detect Maven
5. Use the Command Palette (Ctrl+Shift+P) to run Maven commands

## 🚀 Build and Run Solutions

### Build the Project

```bash
# From the project root directory, build the entire project
mvn clean compile

# Or build and package the project
mvn clean package
```

### Run Individual Solutions

You can run any solution directly using Maven's exec plugin. Here are examples for different categories:

#### Array & String Solutions
```bash
# Run from project root directory
mvn exec:java -Dexec.mainClass="Array.String.MergeStringsAlternately"
mvn exec:java -Dexec.mainClass="Array.String.GreatestCommonDivisorOfStrings"
mvn exec:java -Dexec.mainClass="Array.String.KidsWithTheGreatestNumberOfCandies"
mvn exec:java -Dexec.mainClass="Array.String.CanPlaceFlowers"
mvn exec:java -Dexec.mainClass="Array.String.ReverseVowelsOfAString"
mvn exec:java -Dexec.mainClass="Array.String.ReverseWordsInAString"
mvn exec:java -Dexec.mainClass="Array.String.ProductOfArrayExceptSelf"
mvn exec:java -Dexec.mainClass="Array.String.IncreasingTripletSubsequence"
mvn exec:java -Dexec.mainClass="Array.String.StringCompression"
```

#### Two Pointers Solutions
```bash
mvn exec:java -Dexec.mainClass="TwoPointers.MoveZeroes"
mvn exec:java -Dexec.mainClass="TwoPointers.IsSubsequence"
mvn exec:java -Dexec.mainClass="TwoPointers.ContainerWithMostWater"
mvn exec:java -Dexec.mainClass="TwoPointers.MaxNumberOfKSumPairs"
```

#### Sliding Window Solutions
```bash
mvn exec:java -Dexec.mainClass="SlidingWindow.MaximumAverageSubarrayI"
mvn exec:java -Dexec.mainClass="SlidingWindow.MaximumNumberOfVowelsInASubstringOfGivenLength"
mvn exec:java -Dexec.mainClass="SlidingWindow.MaxConsecutiveOnesIII"
mvn exec:java -Dexec.mainClass="SlidingWindow.LongestSubarrayOf1sAfterDeletingOneElement"
```

#### Prefix Sum Solutions
```bash
mvn exec:java -Dexec.mainClass="PrefixSum.FindTheHighestAltitude"
mvn exec:java -Dexec.mainClass="PrefixSum.FindPivotIndex"
```

#### HashMap/Set Solutions
```bash
mvn exec:java -Dexec.mainClass="HashMap.Set.FindTheDifferenceOfTwoArrays"
mvn exec:java -Dexec.mainClass="HashMap.Set.UniqueNumberOfOccurrences"
mvn exec:java -Dexec.mainClass="HashMap.Set.DetermineIfTwoStringsAreClose"
mvn exec:java -Dexec.mainClass="HashMap.Set.EqualRowAndColumnPairs"
```

#### Stack Solutions
```bash
mvn exec:java -Dexec.mainClass="Stack.RemovingStarsFromAString"
mvn exec:java -Dexec.mainClass="Stack.AsteroidCollision"
mvn exec:java -Dexec.mainClass="Stack.DecodeString"
```

#### Queue Solutions
```bash
mvn exec:java -Dexec.mainClass="Queue.RecentCounter"
mvn exec:java -Dexec.mainClass="Queue.Dota2Senate"
```

#### LinkedList Solutions
```bash
mvn exec:java -Dexec.mainClass="LinkedList.DeleteTheMiddleNodeOfALinkedList"
mvn exec:java -Dexec.mainClass="LinkedList.MaximumTwinSumOfALinkedList"
mvn exec:java -Dexec.mainClass="LinkedList.OddEvenLinkedList"
mvn exec:java -Dexec.mainClass="LinkedList.ReverseLinkedList"
```

#### BinarySearchTree Solutions
```bash
mvn exec:java -Dexec.mainClass="BinarySearchTree.SearchInABinarySearchTree"
mvn exec:java -Dexec.mainClass="BinarySearchTree.DeleteNodeInABST"
```

#### BinaryTree DFS Solutions
```bash
mvn exec:java -Dexec.mainClass="BinaryTree.DFS.MaximumDepthOfBinaryTree"
mvn exec:java -Dexec.mainClass="BinaryTree.DFS.LeafSimilarTrees"
mvn exec:java -Dexec.mainClass="BinaryTree.DFS.CountGoodNodesInBinaryTree"
mvn exec:java -Dexec.mainClass="BinaryTree.DFS.PathSumIII"
mvn exec:java -Dexec.mainClass="BinaryTree.DFS.LongestZigZagPathInABinaryTree"
mvn exec:java -Dexec.mainClass="BinaryTree.DFS.LowestCommonAncestorOfABinaryTree"
```

#### BinaryTree BFS Solutions
```bash
mvn exec:java -Dexec.mainClass="BinaryTree.BFS.BinaryTreeRightSideView"
mvn exec:java -Dexec.mainClass="BinaryTree.BFS.MaximumLevelSumOfABinaryTree"
```

#### Graphs DFS Solutions
```bash
mvn exec:java -Dexec.mainClass="Graphs.DFS.KeysAndRooms"
mvn exec:java -Dexec.mainClass="Graphs.DFS.NumberOfProvinces"
mvn exec:java -Dexec.mainClass="Graphs.DFS.ReorderRoutesToMakeAllPathsLeadToTheCityZero"
mvn exec:java -Dexec.mainClass="Graphs.DFS.EvaluateDivision"
```

#### Graphs BFS Solutions
```bash
mvn exec:java -Dexec.mainClass="Graphs.BFS.NearestExitFromEntranceInMaze"
mvn exec:java -Dexec.mainClass="Graphs.BFS.RottingOranges"
```

#### BinarySearch Solutions
```bash
mvn exec:java -Dexec.mainClass="BinarySearch.GuessNumberHigherOrLower"
```

#### Backtracking Solutions
```bash
mvn exec:java -Dexec.mainClass="Backtracking.CombinationSumIII"
mvn exec:java -Dexec.mainClass="Backtracking.LetterCombinationsOfAPhoneNumber"
```

### Alternative: Run from IDE

You can also run the solutions directly from your IDE:

1. **IntelliJ IDEA**: Right-click on any Java file and select "Run 'ClassName'"
2. **VS Code**: Use the Java extension to run individual files
3. **Eclipse**: Right-click on the class and select "Run As" → "Java Application"

### Quick Build Commands

```bash
# Clean and compile
mvn clean compile

# Run tests (if any are added)
mvn test

# Generate JAR file
mvn clean package

# Skip tests during build
mvn clean package -DskipTests
```

## 💡 Solutions Overview

### Array & String Problems
#### 1. Merge Strings Alternately
- **Problem**: Merge two strings by adding letters in alternating order
- **Approach**: Two-pointer technique with string building
- **Time Complexity**: O(n + m)
- **Space Complexity**: O(n + m)
- **Difficulty**: Easy
#### 2. Greatest Common Divisor of Strings
- **Problem**: Find the largest string that divides both input strings
- **Approach**: Mathematical GCD with string validation
- **Time Complexity**: O(n + m)
- **Space Complexity**: O(n + m)
- **Difficulty**: Easy
- **Note**: Refactored to use Java Streams for modern functional programming approach
#### 3. Kids With the Greatest Number of Candies
- **Problem**: Determine which kids can have the greatest number of candies
- **Approach**: Stream-based functional programming with max finding
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)
- **Difficulty**: Easy
- **Note**: Uses Java Streams for elegant functional programming solution
#### 4. Can Place Flowers
- **Problem**: Determine if n new flowers can be planted in a flowerbed without violating the no-adjacent-flowers rule
- **Approach**: Greedy algorithm with boundary condition handling
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Uses short-circuit evaluation to safely handle array boundaries
#### 5. Reverse Vowels of a String
- **Problem**: Reverse only the vowels in a string while keeping consonants in their original positions
- **Approach**: Two-pointer technique with in-place vowel swapping
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Optimized solution using direct character comparison and single-pass algorithm
#### 6. Reverse Words in a String
- **Problem**: Reverse the order of words in a string while maintaining single spaces between words
- **Approach**: String splitting and reverse iteration with StringBuilder
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)
- **Difficulty**: Medium
- **Note**: Handles multiple spaces and empty words efficiently using split() and trim()
#### 7. Product of Array Except Self
- **Problem**: Return an array where each element is the product of all elements except the element at that index
- **Approach**: Two-pass algorithm using left and right product arrays
- **Time Complexity**: O(n)
- **Space Complexity**: O(1) excluding output array
- **Difficulty**: Medium
- **Note**: Optimized solution using constant extra space by reusing the result array
#### 8. Increasing Triplet Subsequence
- **Problem**: Determine if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]
- **Approach**: Greedy algorithm tracking two minimum values
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Medium
- **Note**: Elegant solution using two variables to track the smallest and second smallest elements
#### 9. String Compression
- **Problem**: Compress a string by replacing consecutive duplicate characters with the character followed by its count
- **Approach**: Two-pointer technique with in-place compression
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Medium
- **Note**: Efficient in-place solution using read and write pointers to compress the string without extra space

### Sliding Window Problems
#### 1. Maximum Average Subarray I
- **Problem**: Find a contiguous subarray whose length is equal to k that has the maximum average value
- **Approach**: Sliding window technique with sum optimization
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Efficient single-pass solution using sliding window to avoid recalculating sums
#### 2. Maximum Number of Vowels in a Substring of Given Length
- **Problem**: Find the maximum number of vowel letters in any substring of length k
- **Approach**: Sliding window technique with vowel counting optimization
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Medium
- **Note**: Efficient sliding window solution that maintains vowel count while moving the window, avoiding recounting for each position
#### 3. Max Consecutive Ones III
- **Problem**: Find the maximum number of consecutive 1's in a binary array if you can flip at most k 0's
- **Approach**: Sliding window technique with zero counting and window shrinking
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Medium
- **Note**: Optimal sliding window solution that maintains a valid window with at most k zeros, efficiently expanding and shrinking the window
#### 4. Longest Subarray of 1's After Deleting One Element
- **Problem**: Find the size of the longest subarray containing only 1's after deleting exactly one element
- **Approach**: Sliding window technique maintaining at most one 0 in the window
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Medium
- **Note**: Efficient sliding window solution that finds the longest subarray with at most one zero, then subtracts 1 since we must delete exactly one element

### Prefix Sum Problems
#### 1. Find the Highest Altitude
- **Problem**: Find the highest altitude reached during a journey given altitude gains
- **Approach**: Prefix sum technique to track cumulative altitude changes
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Simple prefix sum solution that maintains running total of altitude changes and tracks the maximum altitude reached
#### 2. Find Pivot Index
- **Problem**: Find the pivot index where the sum of elements on the left equals the sum on the right
- **Approach**: Prefix sum technique with total sum calculation and left sum tracking
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Efficient two-pass solution that first calculates total sum, then finds pivot by comparing left and right sums

### HashMap/Set Problems
#### 1. Find the Difference of Two Arrays
- **Problem**: Find distinct integers that are present in one array but not in the other
- **Approach**: HashSet for efficient lookups and duplicate removal
- **Time Complexity**: O(n + m)
- **Space Complexity**: O(n + m)
- **Difficulty**: Easy
- **Note**: Uses HashSet to convert arrays to unique elements, then performs set difference operations for efficient comparison
#### 2. Unique Number of Occurrences
- **Problem**: Determine if the number of occurrences of each value in the array is unique
- **Approach**: HashMap for frequency counting and HashSet for uniqueness validation
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)
- **Difficulty**: Easy
- **Note**: Efficient solution using HashMap to count frequencies and HashSet to verify all occurrence counts are unique
#### 3. Determine if Two Strings Are Close
- **Problem**: Determine if two strings are close based on swap and transform operations
- **Approach**: HashMap with frequency counting and distribution comparison
- **Time Complexity**: O(n + k) where n is string length, k is unique characters
- **Space Complexity**: O(k)
- **Difficulty**: Medium
- **Note**: Efficient solution using frequency maps to check same characters and frequency distributions
#### 4. Equal Row and Column Pairs
- **Problem**: Count the number of pairs (ri, cj) such that row ri and column cj are equal
- **Approach**: HashMap counting for row and column patterns with multiplication
- **Time Complexity**: O(n²) where n is the grid size
- **Space Complexity**: O(n²)
- **Difficulty**: Medium
- **Note**: Optimal O(n²) solution using HashMap to count pattern frequencies and multiply matching counts

### Stack Problems
#### 1. Removing Stars From a String
- **Problem**: Remove all stars from a string, where each star removes the closest non-star character to its left
- **Approach**: Stack-based simulation of character removal operations
- **Time Complexity**: O(n) where n is the length of the string
- **Space Complexity**: O(n) for the stack
- **Difficulty**: Medium
- **Note**: Efficient stack-based solution that simulates the removal operation by pushing non-star characters and popping when encountering stars
#### 2. Asteroid Collision
- **Problem**: Simulate asteroid collisions where positive values move right, negative move left, and smaller asteroids explode on collision
- **Approach**: Stack-based simulation with optimized collision handling
- **Time Complexity**: O(n) where n is the number of asteroids
- **Space Complexity**: O(n) for the stack
- **Difficulty**: Medium
- **Note**: Optimized solution using stack to efficiently handle asteroid collisions with clean logic and minimal overhead
#### 3. Decode String
- **Problem**: Decode a string containing encoded patterns like "3[a]2[bc]" into "aaabcbc"
- **Approach**: Stack-based approach with separate stacks for strings and numbers
- **Time Complexity**: O(n × m) where n is input length, m is maximum number
- **Space Complexity**: O(n) for the stacks
- **Difficulty**: Medium
- **Note**: Efficient solution using two stacks to handle nested patterns and avoid expensive string insertions

### Queue Problems
#### 1. Number of Recent Calls
- **Problem**: Track the number of recent requests within the last 3000 milliseconds
- **Approach**: Queue-based sliding window with automatic cleanup of old requests
- **Time Complexity**: O(n) where n is the number of requests (amortized O(1) per ping)
- **Space Complexity**: O(n) for storing request timestamps
- **Difficulty**: Easy
- **Note**: Efficient solution using queue to maintain sliding window of recent requests with automatic cleanup
#### 2. Dota2 Senate
- **Problem**: Predict which party (Radiant or Dire) will win the senate voting process
- **Approach**: Queue-based simulation where senators ban opposing senators in order
- **Time Complexity**: O(n) where n is the number of senators
- **Space Complexity**: O(n) for storing senator indices in queues
- **Difficulty**: Medium
- **Note**: Efficient solution using two queues to simulate the voting process and determine the winner

### Two Pointers Problems
#### 1. Move Zeroes
- **Problem**: Move all 0's to the end of the array while maintaining the relative order of non-zero elements
- **Approach**: Two-pointer technique with in-place swapping
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Efficient single-pass solution using left and right pointers to swap non-zero elements with zeros
#### 2. Is Subsequence
- **Problem**: Determine if string s is a subsequence of string t
- **Approach**: Two-pointer technique with character matching
- **Time Complexity**: O(n + m)
- **Space Complexity**: O(1)
- **Difficulty**: Easy
- **Note**: Simple and efficient solution using two pointers to traverse both strings simultaneously
#### 3. Container With Most Water
- **Problem**: Find two lines that together with the x-axis form a container that holds the most water
- **Approach**: Two-pointer technique starting from both ends and moving inward
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Difficulty**: Medium
- **Note**: Optimal solution using two pointers to maximize area by moving the pointer with smaller height
#### 4. Max Number of K-Sum Pairs
- **Problem**: Find the maximum number of operations to remove pairs of numbers that sum to k
- **Approach**: HashMap for frequency counting or two-pointer technique after sorting
- **Time Complexity**: O(n) for HashMap approach, O(n log n) for two-pointer approach
- **Space Complexity**: O(n) for HashMap approach, O(1) for two-pointer approach
- **Difficulty**: Medium
- **Note**: Two solutions provided - HashMap approach for better time complexity and two-pointer approach for better space complexity

### LinkedList Problems
#### 1. Delete the Middle Node of a Linked List
- **Problem**: Delete the middle node of a linked list given its head
- **Approach**: Two-pointer technique (tortoise and hare) to find middle node efficiently
- **Time Complexity**: O(n) - single pass through the list
- **Space Complexity**: O(1) - constant extra space
- **Difficulty**: Medium
- **Note**: Optimal solution using slow and fast pointers to locate middle node in one pass, then delete it by updating previous node's next pointer
#### 2. Odd Even Linked List
- **Problem**: Group all odd-indexed nodes together followed by even-indexed nodes
- **Approach**: Separate odd and even nodes into two lists, then concatenate them
- **Time Complexity**: O(n) - single pass through the list
- **Space Complexity**: O(1) - constant extra space
- **Difficulty**: Medium
- **Note**: Efficient solution that maintains two separate chains for odd and even positioned nodes, then links them together
#### 3. Maximum Twin Sum of a Linked List
- **Problem**: Find the maximum sum of twin pairs in a linked list (twin pairs: 0th with n-1th, 1st with n-2nd, etc.)
- **Approach**: Tortoise and hare algorithm to find middle, reverse second half, then compare twin pairs
- **Time Complexity**: O(n) - three passes through the list
- **Space Complexity**: O(1) - constant extra space
- **Difficulty**: Medium
- **Note**: Optimized solution using slow/fast pointers to find middle efficiently, then reverse second half for twin pair comparison
#### 4. Reverse Linked List
- **Problem**: Reverse a singly linked list
- **Approach**: Iterative approach using three pointers to reverse links
- **Time Complexity**: O(n) - single pass through the list
- **Space Complexity**: O(1) - constant extra space
- **Difficulty**: Easy
- **Note**: Classic iterative solution using prev, current, and next pointers to reverse the direction of links

### BinarySearchTree Problems
#### 1. Search in a Binary Search Tree
- **Problem**: Search for a node with a given value in a Binary Search Tree
- **Approach**: Iterative traversal using BST property (left < root < right)
- **Time Complexity**: O(log n) average, O(n) worst case - eliminates half the tree at each step
- **Space Complexity**: O(1) - constant space using iterative approach
- **Difficulty**: Easy
- **Note**: Efficient iterative solution that leverages BST property to navigate directly to the target without visiting unnecessary nodes

#### 2. Delete Node in a BST
- **Problem**: Delete a node with a given key from a Binary Search Tree while maintaining BST property
- **Approach**: Iterative deletion handling four cases: leaf node, single child, and two children using inorder successor
- **Time Complexity**: O(h) where h is the height of the tree - traverses to find node and successor
- **Space Complexity**: O(1) - constant space using iterative approach
- **Difficulty**: Medium
- **Note**: Comprehensive iterative solution that handles all deletion cases while maintaining BST properties using inorder successor for nodes with two children

### BinaryTree DFS Problems
#### 1. Maximum Depth of Binary Tree
- **Problem**: Find the maximum depth (height) of a binary tree
- **Approach**: Iterative stack-based DFS traversal tracking node depths
- **Time Complexity**: O(n) - visits each node once
- **Space Complexity**: O(h) - where h is the height of the tree (stack space)
- **Difficulty**: Easy
- **Note**: Efficient iterative solution using two stacks to track nodes and their corresponding depths, avoiding recursion
#### 2. Leaf-Similar Trees
- **Problem**: Determine if two binary trees are leaf-similar (have the same leaf value sequence)
- **Approach**: DFS traversal to collect leaf values from both trees, then compare sequences
- **Time Complexity**: O(n + m) - where n and m are the number of nodes in each tree
- **Space Complexity**: O(n + m) - for storing leaf values from both trees
- **Difficulty**: Easy
- **Note**: Efficient solution using DFS to collect leaf values in order, then comparing the sequences using equals() method
#### 3. Count Good Nodes in Binary Tree
- **Problem**: Count nodes where the path from root to that node contains no nodes with value greater than the current node
- **Approach**: DFS traversal tracking maximum value seen in path from root
- **Time Complexity**: O(n) - visits each node once
- **Space Complexity**: O(h) - where h is the height of the tree (recursion stack)
- **Difficulty**: Medium
- **Note**: Efficient DFS solution that tracks the maximum value in the path and counts nodes that are greater than or equal to this maximum
#### 4. Path Sum III
- **Problem**: Find the number of paths where the sum of values along the path equals targetSum (path doesn't need to start/end at root or leaf)
- **Approach**: Iterative stack-based DFS traversal with path sum tracking
- **Time Complexity**: O(n²) - visits each node and explores all paths from each node
- **Space Complexity**: O(h) - where h is the height of the tree (stack space)
- **Difficulty**: Medium
- **Note**: Efficient iterative solution using two stacks to track nodes and their corresponding path sums, avoiding recursion while maintaining O(h) space complexity
#### 5. Longest ZigZag Path in a Binary Tree
- **Problem**: Find the length of the longest zigzag path in a binary tree (alternating left-right directions)
- **Approach**: DFS traversal tracking direction and path length for zigzag patterns
- **Time Complexity**: O(n) - visits each node once
- **Space Complexity**: O(h) - where h is the height of the tree (recursion stack)
- **Difficulty**: Medium
- **Note**: Efficient DFS solution that tracks zigzag direction and explores both left and right starting directions to find maximum zigzag path length
#### 6. Lowest Common Ancestor of a Binary Tree
- **Problem**: Find the lowest common ancestor (LCA) of two given nodes in a binary tree
- **Approach**: Recursive DFS traversal with post-order processing to detect LCA
- **Time Complexity**: O(n) - visits each node once
- **Space Complexity**: O(h) - where h is the height of the tree (recursion stack)
- **Difficulty**: Medium
- **Note**: Elegant recursive solution that uses post-order traversal to find the first node where both target nodes are found in different subtrees. Handles edge cases where one node is descendant of the other

### BinaryTree BFS Problems
#### 1. Binary Tree Right Side View
- **Problem**: Given the root of a binary tree, return the values of the nodes visible from the right side (top to bottom)
- **Approach**: BFS level-order traversal, capturing the rightmost node at each level
- **Time Complexity**: O(n) - visits each node once
- **Space Complexity**: O(w) - where w is the maximum width of the tree (queue space)
- **Difficulty**: Medium
- **Note**: Efficient BFS solution using queue to process nodes level by level, adding the last node (rightmost) of each level to the result

#### 2. Maximum Level Sum of a Binary Tree
- **Problem**: Find the smallest level (1-indexed) where the sum of all node values at that level is maximal
- **Approach**: BFS level-order traversal, calculating sum for each level and tracking the maximum
- **Time Complexity**: O(n) - visits each node once
- **Space Complexity**: O(w) - where w is the maximum width of the tree (queue space)
- **Difficulty**: Medium
- **Note**: Efficient BFS solution that processes each level completely, calculates level sum, and updates the maximum sum level. Returns the smallest level number when multiple levels have the same maximum sum

### Graphs DFS Problems
#### 1. Keys and Rooms
- **Problem**: Determine if all rooms can be visited starting from room 0, where each room contains keys to other rooms
- **Approach**: Iterative DFS using stack to traverse all accessible rooms from room 0
- **Time Complexity**: O(V + E) - where V is number of rooms and E is total number of keys
- **Space Complexity**: O(V) - for visited array and stack
- **Difficulty**: Medium
- **Note**: Efficient iterative DFS solution that simulates recursive traversal using explicit stack, avoiding potential stack overflow issues

#### 2. Number of Provinces
- **Problem**: Find the number of connected components in an undirected graph represented by an adjacency matrix
- **Approach**: Iterative DFS using explicit stack to explore connected components
- **Time Complexity**: O(n²) - where n is the number of cities
- **Space Complexity**: O(n) - for visited array and stack
- **Difficulty**: Medium
- **Note**: Efficient iterative DFS solution that finds all connected components by marking visited cities and counting separate provinces

#### 3. Reorder Routes to Make All Paths Lead to the City Zero
- **Problem**: Find the minimum number of edge reversals needed so all paths lead to city 0
- **Approach**: Build bidirectional graph and use DFS from city 0 to count edges pointing away
- **Time Complexity**: O(n) - where n is the number of cities
- **Space Complexity**: O(n) - for adjacency list and visited array
- **Difficulty**: Medium
- **Note**: Efficient DFS solution that builds bidirectional graph and counts edges pointing away from city 0 during traversal

#### 4. Evaluate Division
- **Problem**: Evaluate division queries given a set of equations and their values
- **Approach**: Build weighted directed graph and use DFS to find division paths
- **Time Complexity**: O(M × N) - where M is number of equations, N is number of queries
- **Space Complexity**: O(M) - for graph storage
- **Difficulty**: Medium
- **Note**: Efficient graph-based solution that uses DFS to find paths between variables and multiply weights along the path

### Graphs BFS Problems
#### 1. Nearest Exit from Entrance in Maze
- **Problem**: Find the shortest path from entrance to nearest border cell (exit) in a maze
- **Approach**: Breadth-First Search (BFS) for shortest path in unweighted grid
- **Time Complexity**: O(m × n) - where m and n are maze dimensions
- **Space Complexity**: O(m × n) - for BFS queue in worst case
- **Difficulty**: Medium
- **Note**: Efficient BFS solution that explores level by level to guarantee finding shortest path to nearest exit

#### 2. Rotting Oranges
- **Problem**: Find minimum time for all fresh oranges to rot when fresh oranges adjacent to rotten ones become rotten every minute
- **Approach**: BFS simulation of rotting process with time tracking
- **Time Complexity**: O(m × n) - where m and n are grid dimensions
- **Space Complexity**: O(m × n) - for BFS queue in worst case
- **Difficulty**: Medium
- **Note**: Efficient BFS solution that simulates minute-by-minute rotting process and returns -1 if some oranges can never rot

### BinarySearch Problems
#### 1. Guess Number Higher or Lower
- **Problem**: Find the picked number using binary search with a guess API that returns -1 (higher), 1 (lower), or 0 (correct)
- **Approach**: Binary search with mid calculation and API integration
- **Time Complexity**: O(log n) - binary search eliminates half the search space each iteration
- **Space Complexity**: O(1) - constant extra space
- **Difficulty**: Easy
- **Note**: Efficient binary search solution that uses the guess API to determine search direction and avoid integer overflow with mid calculation

### Backtracking Problems
#### 1. Combination Sum III
- **Problem**: Find all valid combinations of k numbers that sum up to n using only numbers 1-9, each used at most once
- **Approach**: Recursive backtracking with constraint satisfaction
- **Time Complexity**: O(C(9,k) × k) - where C(9,k) is combinations of k from 9
- **Space Complexity**: O(k) for recursion + O(C(9,k) × k) for results
- **Difficulty**: Medium
- **Note**: Efficient backtracking solution that explores all valid combinations while avoiding duplicates through systematic ordering

#### 2. Letter Combinations of a Phone Number
- **Problem**: Given a string containing digits from 2-9, return all possible letter combinations that the number could represent on a telephone keypad
- **Approach**: Recursive backtracking with phone keypad mapping
- **Time Complexity**: O(4^n × n) - where n is the length of digits, 4^n combinations, O(n) to build each string
- **Space Complexity**: O(n) - recursion stack depth
- **Difficulty**: Medium
- **Note**: Efficient recursive backtracking solution that systematically explores all possible letter combinations using the classic choose-explore-unchoose pattern

## 📚 Good to Know

### Project Structure

This is a **Maven-based Java project** with the following characteristics:
- **Java Version**: Java 21 (LTS)
- **Build Tool**: Apache Maven 3.6+
- **Project Layout**: Standard Maven directory structure
- **Package Structure**: Organized by algorithm categories

### Shared Data Structures

#### ListNode (LinkedList)
```bash
# Located in: src/main/java/LinkedList/ListNode.java
# Used by all LinkedList problem solutions
```

#### TreeNode (BinarySearchTree)
```bash
# Located in: src/main/java/BinarySearchTree/TreeNode.java
# Used by all BinarySearchTree problem solutions
```

#### TreeNode (BinaryTree)
```bash
# Located in: src/main/java/BinaryTree/TreeNode.java
# Used by all BinaryTree DFS and BFS problem solutions
```

### Maven Configuration

The project uses a minimal Maven configuration optimized for LeetCode solutions:
- **Compiler**: Java 21 with UTF-8 encoding
- **Packaging**: JAR format
- **Dependencies**: None (pure Java solutions)
- **Plugins**: Standard Maven compiler plugin

## 🎯 Key Features

- ✅ **Clean, well-commented code** with detailed explanations
- ✅ **Multiple solution approaches** where applicable
- ✅ **Time and space complexity analysis** for each solution
- ✅ **Modern Java features** including Streams and functional programming
- ✅ **Comprehensive test cases** with main methods
- ✅ **Consistent coding style** and best practices
- ✅ **WARP.md integration** for enhanced terminal development experience

## 🚀 Recent Updates

- **🆕 Added Evaluate Division** - Added graph DFS solution with efficient O(M × N) approach for evaluating division queries using weighted directed graph and DFS path finding
- **🆕 Added Reorder Routes to Make All Paths Lead to the City Zero** - Added graph DFS solution with efficient O(n) approach for finding minimum edge reversals needed to make all paths lead to city 0
- **🆕 Added Guess Number Higher or Lower** - Added binary search solution with efficient O(log n) approach for finding the picked number using the guess API
- **🆕 Added Number of Provinces** - Added number of provinces solution with efficient O(n²) iterative DFS approach for finding connected components in adjacency matrix
- **🆕 Added Keys and Rooms** - Added keys and rooms solution with efficient O(V + E) iterative DFS approach for determining room accessibility starting from room 0
- **🆕 Added Rotting Oranges** - Added rotting oranges simulation solution with efficient O(m × n) BFS approach for tracking minimum time until all oranges rot
- **🆕 Added Nearest Exit from Entrance in Maze** - Added maze navigation solution with efficient O(m × n) BFS approach for finding shortest path to nearest exit
- **🔄 Added Combination Sum III** - Added Combination Sum III solution with efficient O(C(9,k) × k) backtracking approach for finding all valid combinations of k numbers that sum to n
- **🔄 Added Backtracking Solutions** - Added Letter Combinations of a Phone Number solution with efficient O(4^n × n) recursive backtracking approach for generating all possible letter combinations
- **🌲 Enhanced BinarySearchTree Implementation** - Added Delete Node in a BST solution with comprehensive O(h) iterative approach handling all deletion cases
- **🌳 BinaryTree Reorganization** - Restructured BinaryTree solutions into separate DFS and BFS directories for better organization and clarity
- **🆕 Added BinaryTree BFS Solution** - Added Binary Tree Right Side View solution with efficient BFS level-order traversal approach
- **📁 Improved Project Structure** - Moved TreeNode.java to the main BinaryTree directory to be shared between DFS and BFS solutions
- **🧹 Repository Cleanup** - Removed docs folder and simplified GitHub workflows by removing security and dependency submission components
- **⚡ Simplified CI/CD** - Streamlined GitHub Actions workflows to focus on core functionality (CI and monitoring) without security scanning overhead
- **📁 Updated Structure** - Cleaned up repository structure by removing unnecessary documentation and security configurations
- **🔄 Migrated to Maven Project Structure** - Converted from Gradle to Maven for better Java project management and standardization
- **📦 Updated Build System** - All solutions now use Maven for compilation and execution with Java 21 support
- **📚 Enhanced Documentation** - Updated README with comprehensive Maven build instructions and project structure
- **✅ Added Longest ZigZag Path in a Binary Tree** solution with efficient O(n) DFS approach for finding maximum zigzag path length
- **✅ Added Lowest Common Ancestor of a Binary Tree** solution with efficient O(n) recursive DFS approach for finding LCA of two nodes
- **✅ Added Path Sum III** solution with efficient O(n²) iterative stack-based DFS approach for counting paths with target sum
- **✅ Added Count Good Nodes in Binary Tree** solution with efficient O(n) DFS approach for tracking maximum values in paths
- **✅ Added Leaf-Similar Trees** solution with efficient O(n + m) DFS approach for comparing tree leaf sequences
- **✅ Added Maximum Depth of Binary Tree** solution with efficient O(n) iterative stack-based DFS approach for finding tree height
- **✅ Added Maximum Twin Sum of a Linked List** solution with optimized O(n) approach using tortoise and hare algorithm for efficient twin pair calculation
- **✅ Added Reverse Linked List** solution with efficient O(n) iterative approach using three-pointer technique for reversing linked list
- **✅ Added Odd Even Linked List** solution with efficient O(n) node separation technique for grouping odd and even positioned nodes
- **✅ Added Delete the Middle Node of a Linked List** solution with optimal O(n) two-pointer technique for efficient middle node deletion
- **✅ Added Dota2 Senate** solution with efficient O(n) queue-based simulation approach for predicting senate voting winner
- **✅ Added Number of Recent Calls** solution with efficient O(n) queue-based sliding window approach for tracking recent requests
- **✅ Added Decode String** solution with optimized O(n × m) stack-based approach for handling nested encoded patterns
- **✅ Added Asteroid Collision** solution with optimized O(n) stack-based approach for collision simulation
- **✅ Added Removing Stars From a String** solution with efficient O(n) stack-based approach for character removal simulation
- **✅ Added Equal Row and Column Pairs** solution with optimal O(n²) HashMap counting approach for matrix pattern matching
- **✅ Added Determine if Two Strings Are Close** solution with HashMap frequency counting approach for efficient string transformation validation
- **✅ Added Unique Number of Occurrences** solution with HashMap and HashSet approach for efficient frequency uniqueness validation
- **✅ Added Find Pivot Index** solution with efficient prefix sum technique for finding balance point in array
- **✅ Added Find the Highest Altitude** solution with efficient prefix sum technique for tracking cumulative altitude changes
- **✅ Added Longest Subarray of 1's After Deleting One Element** solution with efficient sliding window technique for finding longest subarray after mandatory deletion
- **✅ Added Max Consecutive Ones III** solution with efficient sliding window technique for binary array optimization with zero flipping constraint
- **✅ Added Maximum Number of Vowels in a Substring of Given Length** solution with efficient sliding window technique for vowel counting optimization
- **✅ Added Max Number of K-Sum Pairs** solution with both HashMap and two-pointer approaches for maximum flexibility
- **✅ Added Container With Most Water** solution with optimal two-pointer technique for maximum area calculation
- **✅ Added Maximum Average Subarray I** solution with efficient sliding window technique for subarray optimization
- **✅ Added WARP.md** configuration file for Warp terminal integration and development guidance
- **✅ Added Is Subsequence** solution with efficient two-pointer technique for string subsequence checking
- **✅ Added Move Zeroes** solution with efficient two-pointer technique for in-place array manipulation
- **✅ Added String Compression** solution with efficient in-place two-pointer approach
- **✅ Added Increasing Triplet Subsequence** solution with greedy algorithm approach
- **✅ Added Product of Array Except Self** solution with optimized two-pass algorithm
- **✅ Added Kids With the Greatest Number of Candies** solution with stream-based implementation
- **✅ Refactored Greatest Common Divisor of Strings** to use Java Streams
- **✅ Enhanced README** with better structure and comprehensive documentation

## 🤝 Contributing

While this is a personal learning repository, suggestions and improvements are welcome! Feel free to:

- 🐛 Open issues for bugs or improvements
- 💡 Suggest better solutions or optimizations
- 🔄 Share your own approaches to these problems
- 📚 Contribute to documentation improvements

## 📊 Learning Resources

- [LeetCode 75 Study Plan](https://leetcode.com/studyplan/leetcode-75/)
- [LeetCode Official Website](https://leetcode.com/)
- [Java Documentation](https://docs.oracle.com/en/java/)
- [Java Streams Tutorial](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)
- [Maven Getting Started Guide](https://maven.apache.org/guides/getting-started/)
- [Maven Documentation](https://maven.apache.org/guides/)

## 🏆 Goals

- ✅ Complete all 75 problems in the study plan
- ✅ Provide clean, well-commented solutions
- ✅ Include time and space complexity analysis
- ✅ Document different approaches and optimizations
- ✅ Use modern Java features and best practices
- ✅ Create comprehensive documentation

---

<div align="center">

## Happy Coding! 🎉

Made with ❤️ by [@shawjitesh](https://github.com/shawjitesh)

[![GitHub followers](https://img.shields.io/github/followers/shawjitesh?style=social)](https://github.com/shawjitesh)

</div>
